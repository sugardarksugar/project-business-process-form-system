"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAutoMigrate = exports.setupKnexMigration = exports.setupKnexFile = exports.setupEnvFile = exports.setupSqlite = exports.detectSrcDir = void 0;
const fastest_levenshtein_1 = require("fastest-levenshtein");
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const file_1 = require("../utils/file");
const mysql_to_text_1 = require("./mysql-to-text");
const pg_to_text_1 = require("./pg-to-text");
const sort_tables_1 = require("./sort-tables");
const sqlite_parser_1 = require("./sqlite-parser");
const text_to_knex_1 = require("./text-to-knex");
const text_to_sqlite_1 = require("./text-to-sqlite");
function detectSrcDir() {
    for (const dir of ['src', 'server', '.']) {
        if (fs_1.existsSync(dir)) {
            return dir;
        }
    }
    return '.';
}
exports.detectSrcDir = detectSrcDir;
function setupSqlite(options) {
    const dbTsFile = path_1.join(options.srcDir, 'db.ts');
    if (fs_1.existsSync(dbTsFile)) {
        return;
    }
    file_1.addDependencies('better-sqlite3-schema', '^2.3.5');
    file_1.addDependencies('@types/integer', '^4.0.1', 'dev');
    file_1.addDependencies('better-sqlite3-proxy', '^1.5.0');
    const code = `
import { toSafeMode, newDB, DBInstance } from 'better-sqlite3-schema'

export const dbFile = ${util_1.inspect(options.dbFile)}

export const db: DBInstance = newDB({
  path: dbFile,
  migrate: false,
})

toSafeMode(db)
`;
    file_1.writeSrcFile(dbTsFile, code);
    return;
}
exports.setupSqlite = setupSqlite;
function setupEnvFile(options) {
    const file = path_1.join(options.srcDir, 'env.ts');
    if (fs_1.existsSync(file)) {
        return;
    }
    file_1.addDependencies('dotenv', '^16.0.1');
    file_1.addDependencies('populate-env', '^2.0.0');
    const code = `
import { config } from 'dotenv'
import populateEnv from 'populate-env'

config()

export const env = {
  DB_HOST: 'optional',
  DB_PORT: 1,
  DB_NAME: '',
  DB_USERNAME: '',
  DB_PASSWORD: '',
}

populateEnv(env, { mode: 'halt' })

env.DB_HOST = process.env.DB_HOST
env.DB_PORT = +process.env.DB_PORT!
`;
    file_1.writeSrcFile(file, code);
}
exports.setupEnvFile = setupEnvFile;
function setupKnexFile(options) {
    const { srcDir, db_client } = options;
    const file = 'knexfile.ts';
    if (fs_1.existsSync(file)) {
        return;
    }
    file_1.addDependencies('knex', '^2.3.0');
    let importDir = srcDir;
    if (!importDir.startsWith('.')) {
        importDir = './' + srcDir;
    }
    let code;
    if (db_client.includes('sqlite')) {
        code = `
import type { Knex } from 'knex'
import { dbFile } from '${importDir}/db'

const config: { [key: string]: Knex.Config } = {
  development: {
    client: ${util_1.inspect(db_client)},
    useNullAsDefault: true,
    connection: {
      filename: dbFile,
    },
  }
}

module.exports = config;
`;
    }
    else {
        code = `
import type { Knex } from 'knex'
import { env } from './${srcDir}/env'

const config: { [key: string]: Knex.Config } = {
  development: {
    client: ${util_1.inspect(db_client)},
    connection: {
      database: env.DB_NAME,
      user: env.DB_USERNAME,
      password: env.DB_PASSWORD,
      host: env.DB_HOST,
      port: env.DB_PORT,
      multipleStatements: true,
    },
  }
}

module.exports = config;
`;
    }
    file_1.writeSrcFile(file, code);
}
exports.setupKnexFile = setupKnexFile;
const migrations_dir = 'migrations';
function setupKnexMigration(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs_1.existsSync(migrations_dir)) {
            fs_1.mkdirSync(migrations_dir);
        }
        const { knex, db_client } = options;
        yield checkPendingMigrations(knex);
        log('Scanning existing database schema...');
        const existing_table_list = yield loadTableList(knex, db_client);
        const { up_lines, down_lines } = generateAutoMigrate({
            existing_table_list,
            parsed_table_list: options.parseResult.table_list,
            detect_rename: options.detect_rename,
            db_client: options.db_client,
        });
        if (up_lines.length === 0 && down_lines.length === 0) {
            log('No migration is needed.');
        }
        else {
            const code = `
import { Knex } from "knex";


export async function up(knex: Knex): Promise<void> {
${up_lines.join('\n')}
}


export async function down(knex: Knex): Promise<void> {
${down_lines.join('\n')}
}
`;
            let file = yield knex.migrate.make('auto-migrate', { extension: 'ts' });
            file = file.replace(path_1.join(process.cwd(), migrations_dir), migrations_dir);
            file_1.writeSrcFile(file, code);
        }
        yield knex.destroy();
    });
}
exports.setupKnexMigration = setupKnexMigration;
function generateAutoMigrate(options) {
    const is_sqlite = options.db_client.includes('sqlite');
    const support_timestamp = !is_sqlite;
    const up_lines = [];
    const down_lines = [];
    sort_tables_1.sortTables(options.parsed_table_list).forEach(table => {
        const { name, field_list } = table;
        const existing_table = options.existing_table_list.find(table => table.name === name);
        if (!existing_table) {
            up_lines.push(text_to_knex_1.toKnexCreateTableCode(table));
            down_lines.unshift(`  await knex.schema.dropTableIfExists('${name}')`);
            return;
        }
        const table_up_lines = [];
        const table_down_lines = [];
        const raw_up_lines = [];
        const raw_down_lines = [];
        const new_columns = [];
        const removed_columns = [];
        function compareColumn(field, existing_field) {
            // don't distinct datetime timestamp
            if (field.type === 'datetime' && existing_field.type == 'timestamp') {
                field.type = existing_field.type;
            }
            if (existing_field.type === 'datetime' && field.type == 'timestamp') {
                field.type = existing_field.type;
            }
            if (!support_timestamp &&
                field.type === 'timestamp' &&
                existing_field.type === 'datetime') {
                // avoid non-effective migration
                // knex translates 'timestamp' into 'datetime' for sqlite db when running schema query builder
                field.type = 'datetime';
            }
            if (field.type !== existing_field.type ||
                field.is_unsigned !== existing_field.is_unsigned) {
                if (is_sqlite &&
                    field.type.match(/^enum/i) &&
                    existing_field.type.match(/^enum/i)) {
                    raw_up_lines.push(alterSqliteEnum(table, field));
                    raw_down_lines.unshift(alterSqliteEnum(table, existing_field));
                }
                else if (is_sqlite) {
                    raw_up_lines.push(alterSqliteField(table, field));
                    raw_down_lines.unshift(alterSqliteField(table, existing_field));
                }
                else {
                    table_up_lines.push(alterType(field));
                    table_down_lines.unshift(alterType(existing_field));
                }
            }
            if (field.is_primary_key !== existing_field.is_primary_key) {
                table_up_lines.push(alterPrimaryKey(field));
                table_down_lines.unshift(alterPrimaryKey(existing_field));
            }
            if (field.is_unique !== existing_field.is_unique) {
                table_up_lines.push(alterUnique(field));
                table_down_lines.unshift(alterUnique(existing_field));
            }
            if (field.is_null !== existing_field.is_null) {
                table_up_lines.push(alterNullable(field));
                table_down_lines.unshift(alterNullable(existing_field));
            }
            // add foreign key
            if (field.references && !existing_field.references) {
                table_up_lines.push(addForeignKey(field));
                table_down_lines.unshift(dropForeignKey(field));
            }
            // drop foreign key
            else if (!field.references && existing_field.references) {
                table_up_lines.push(dropForeignKey(existing_field));
                table_down_lines.unshift(addForeignKey(existing_field));
            }
            // change foreign key
            else if (field.references &&
                existing_field.references &&
                (field.references.table !== existing_field.references.table ||
                    field.references.field !== existing_field.references.field)) {
                table_up_lines.push(dropForeignKey(existing_field));
                table_down_lines.unshift(addForeignKey(existing_field));
                table_up_lines.push(addForeignKey(field));
                table_down_lines.unshift(dropForeignKey(field));
            }
        }
        field_list.forEach(field => {
            const { name } = field;
            const existing_field = existing_table.field_list.find(field => field.name === name);
            // detect new columns
            if (!existing_field) {
                new_columns.push(field);
                return;
            }
            compareColumn(field, existing_field);
        });
        // detected removed columns
        existing_table.field_list.forEach(existing_field => {
            const { name } = existing_field;
            if (name === 'created_at' ||
                name === 'updated_at' ||
                table.field_list.some(field => field.name === name)) {
                return;
            }
            removed_columns.push(existing_field);
        });
        if (options.detect_rename &&
            new_columns.length === removed_columns.length) {
            for (let i = 0; i < new_columns.length; i++) {
                const field = new_columns[i];
                const new_field_name = field.name;
                const existing_field_name = fastest_levenshtein_1.closest(field.name, removed_columns.map(existing_field => existing_field.name));
                const j = removed_columns.findIndex(existing_field => existing_field.name === existing_field_name);
                const existing_field = removed_columns[j];
                compareColumn(Object.assign(Object.assign({}, field), { name: existing_field_name }), existing_field);
                table_up_lines.push(renameColumn(existing_field_name, new_field_name));
                table_down_lines.unshift(renameColumn(new_field_name, existing_field_name));
                new_columns.splice(i, 1);
                removed_columns.splice(j, 1);
                i--;
            }
        }
        function addDropColumn(field, options) {
            if (is_sqlite) {
                /* sqlite version */
                const table = wrapSqliteName(name);
                const col = wrapSqliteName(field.name);
                const { references, is_unique } = field;
                const quoted_field = Object.assign(Object.assign({}, field), { name: col, is_unique: false });
                if (references) {
                    quoted_field.references = {
                        type: references.type,
                        table: wrapSqliteName(references.table),
                        field: wrapSqliteName(references.field),
                    };
                }
                const body = text_to_sqlite_1.toSqliteColumnSql(quoted_field);
                options.raw_add_lines.push(`  await knex.raw(${util_1.inspect(`alter table ${table} add column ${body}`)})`);
                options.raw_drop_lines.unshift(`  await knex.raw(${util_1.inspect(`alter table ${table} drop column ${col}`)})`);
                if (is_unique) {
                    options.raw_add_lines.push(`  await knex.schema.alterTable(${table}, table => table.unique([${col}]))`);
                    options.raw_drop_lines.unshift(`  await knex.schema.alterTable(${table}, table => table.dropUnique([${col}]))`);
                }
            }
            else {
                /* knex version */
                const name = util_1.inspect(field.name);
                options.table_add_lines.push(text_to_knex_1.toKnexCreateColumnCode(field));
                options.table_drop_lines.unshift(`table.dropColumn(${name})`);
            }
        }
        // add new columns
        new_columns.forEach(field => {
            addDropColumn(field, {
                table_add_lines: table_up_lines,
                table_drop_lines: table_down_lines,
                raw_add_lines: raw_up_lines,
                raw_drop_lines: raw_down_lines,
            });
        });
        // drop removed columns
        removed_columns.forEach(existing_field => {
            addDropColumn(existing_field, {
                table_drop_lines: table_up_lines,
                table_add_lines: table_down_lines,
                raw_drop_lines: raw_up_lines,
                raw_add_lines: raw_down_lines,
            });
        });
        function mergeLines(lines) {
            return lines
                .map(line => '    ' + line.trim())
                .join('\n')
                .replace(/\n\n/g, '\n');
        }
        if (table_up_lines.length > 0) {
            up_lines.push(`  await knex.schema.alterTable('${name}', table => {
${mergeLines(table_up_lines)}
  })`);
        }
        up_lines.push(...raw_up_lines);
        if (table_down_lines.length > 0) {
            down_lines.unshift(`  await knex.schema.alterTable('${name}', table => {
${mergeLines(table_down_lines)}
  })`);
        }
        down_lines.unshift(...raw_down_lines);
    });
    return { up_lines, down_lines };
}
exports.generateAutoMigrate = generateAutoMigrate;
function alterSqliteField(table, field) {
    if (!field.is_null) {
        throw new Error(`alter non-nullable column (${table.name}.${field.name}) is not supported in sqlite`);
    }
    const code = `
  {
    const rows = await knex.select('id', '${field.name}').from('${table.name}')
    await knex.raw('alter table \`${table.name}\` drop column \`${field.name}\`')
    await knex.raw("alter table \`${table.name}\` add column \`${field.name}\` ${field.type}")
    for (let row of rows) {
      await knex('${table.name}').update({ ${field.name}: row.${field.name} }).where({ id: row.id })
    }
  }`;
    return '  ' + code.trim();
}
function alterSqliteEnum(table, field) {
    if (!field.is_null) {
        throw new Error(`alter non-nullable column (${table.name}.${field.name}) is not supported in sqlite`);
    }
    const values = field.type.replace(/enum/i, '');
    const code = `
  {
    const rows = await knex.select('id', '${field.name}').from('${table.name}')
    await knex.raw('alter table \`${table.name}\` drop column \`${field.name}\`')
    await knex.raw("alter table \`${table.name}\` add column \`${field.name}\` text check (\`${field.name}\` in ${values})")
    for (let row of rows) {
      await knex('${table.name}').update({ ${field.name}: row.${field.name} }).where({ id: row.id })
    }
  }`;
    return '  ' + code.trim();
}
function alterType(field) {
    let code = 'table';
    code += text_to_knex_1.toKnexCreateColumnTypeCode(field);
    if (field.is_null) {
        code += '.nullable()';
    }
    else {
        code += '.notNullable()';
    }
    code += '.alter()';
    return code;
}
function alterPrimaryKey(field) {
    if (field.is_unique) {
        return `table.primary([${util_1.inspect(field.name)}])`;
    }
    else {
        return `table.dropPrimary([${util_1.inspect(field.name)}])`;
    }
}
function alterUnique(field) {
    if (field.is_unique) {
        return `table.unique([${util_1.inspect(field.name)}])`;
    }
    else {
        return `table.dropUnique([${util_1.inspect(field.name)}])`;
    }
}
function alterNullable(field) {
    if (field.is_null) {
        return `table.setNullable(${util_1.inspect(field.name)})`;
    }
    else {
        return `table.dropNullable(${util_1.inspect(field.name)})`;
    }
}
function addForeignKey(field) {
    if (!field.references) {
        return '';
    }
    return `table.foreign(${util_1.inspect(field.name)}).references(${util_1.inspect(field.references.table + '.' + field.references.field)})`;
}
function dropForeignKey(field) {
    return `table.dropForeign(${util_1.inspect(field.name)})`;
}
function renameColumn(from, to) {
    return `table.renameColumn(${util_1.inspect(from)}, ${util_1.inspect(to)})`;
}
function loadTableList(knex, db_client) {
    return __awaiter(this, void 0, void 0, function* () {
        if (db_client.includes('sqlite')) {
            const rows = yield knex.raw(/* sql */ `select name, sql, type from sqlite_master`);
            return sqlite_parser_1.parseTableSchema(rows);
        }
        if (db_client === 'pg' || db_client.includes('postgres')) {
            return yield pg_to_text_1.scanPGTableSchema(knex);
        }
        if (db_client.includes('mysql')) {
            return yield mysql_to_text_1.scanMysqlTableSchema(knex);
        }
        throw new Error('unknown db_client: ' + db_client);
    });
}
function checkPendingMigrations(knex) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = fs_1.readdirSync(migrations_dir);
        if (files.length === 0) {
            return;
        }
        const status = yield knex.migrate.status().catch((e) => __awaiter(this, void 0, void 0, function* () {
            const hasTable = yield knex.schema.hasTable('knex_migrations');
            if (!hasTable) {
                return -files.length;
            }
            throw e;
        }));
        if (status === 0) {
            return;
        }
        console.error('Error: not migrated to latest version.');
        console.error("Please run 'npx knex migrate:latest' first, then re-run this auto-migrate command.");
        process.exit(1);
    });
}
const log = console.error.bind(console);
const quotes = ['"', "'", '`'];
function wrapSqliteName(name) {
    for (const quote of quotes) {
        if (name.startsWith(quote) && name.endsWith(quote)) {
            name = name.slice(1, name.length - 1);
            break;
        }
    }
    return '`' + name + '`';
}
