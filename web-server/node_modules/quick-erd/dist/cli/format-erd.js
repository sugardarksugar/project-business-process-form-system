#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const ast_1 = require("../core/ast");
const table_1 = require("../core/table");
function parseArgs() {
    let inFile = null;
    let refFile = null;
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === '-r' || arg === '--ref') {
            i++;
            arg = process.argv[i];
            if (!arg) {
                console.error('missing reference filename in argument');
                process.exit(1);
            }
            refFile = arg;
        }
        else {
            inFile = arg;
        }
    }
    if (!inFile) {
        console.error('missing filename in argument');
        process.exit(1);
    }
    return { inFile, refFile };
}
function main() {
    const { inFile, refFile } = parseArgs();
    const text = fs_1.default.readFileSync(inFile).toString();
    const result = ast_1.parse(text);
    if (refFile) {
        const refText = fs_1.default.readFileSync(refFile).toString();
        const refResult = ast_1.parse(refText);
        sortWithRef(result.table_list, refResult.table_list);
        result.table_list.forEach(table => {
            const refTable = refResult.table_list.find(t => t.name === table.name);
            if (refTable) {
                sortWithRef(table.field_list, refTable.field_list);
            }
        });
    }
    const newText = table_1.astToText(result) + '\n';
    if (newText === text) {
        // eslint-disable-next-line no-console
        console.log(`Skip ${inFile}: already formatted`);
        return;
    }
    fs_1.default.writeFileSync(inFile + backupFileSuffix(), text);
    fs_1.default.writeFileSync(inFile, newText);
    // eslint-disable-next-line no-console
    console.log('Formatted', inFile);
}
function sortWithRef(list, refList) {
    const refNames = refList.map(x => x.name);
    const listNames = list.map(x => x.name);
    const newItems = [];
    const oldItems = [];
    list.forEach(item => {
        if (refNames.includes(item.name)) {
            oldItems.push(item);
        }
        else {
            newItems.push(item);
        }
    });
    for (let i = 0; i < oldItems.length; i++) {
        list[i] = oldItems[i];
    }
    for (let i = 0; i < newItems.length; i++) {
        list[i + oldItems.length] = newItems[i];
    }
    list.sort((a, b) => {
        let aIdx = refNames.indexOf(a.name);
        let bIdx = refNames.indexOf(b.name);
        if (aIdx !== -1 && bIdx !== -1) {
            return aIdx - bIdx;
        }
        aIdx = listNames.indexOf(a.name);
        bIdx = listNames.indexOf(b.name);
        return aIdx - bIdx;
    });
}
function backupFileSuffix() {
    const date = new Date();
    return ('.bk_' +
        date.getFullYear() +
        d2(date.getMonth() + 1) +
        d2(date.getDate()) +
        d2(date.getHours()) +
        d2(date.getMinutes()) +
        d2(date.getSeconds()));
}
function d2(x) {
    if (x < 10) {
        return '0' + x;
    }
    return x;
}
main();
