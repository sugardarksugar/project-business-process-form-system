"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printTables = exports.astToText = void 0;
const enum_1 = require("./enum");
const guide_1 = require("./guide");
const meta_1 = require("./meta");
function tableToString(table) {
    return `
${table.name}
${'-'.repeat(table.name.length)}
${table.field_list.map(fieldToString).join('\n')}
`;
}
function fieldToString(field) {
    let type = field.type;
    if (type.match(/^enum/i)) {
        type = enum_1.formatEnum(type);
    }
    let text = `${field.name} ${type}`;
    if (field.is_unsigned) {
        text += ` unsigned`;
    }
    if (field.is_null) {
        text += ' NULL';
    }
    if (field.is_unique) {
        text += ' unique';
    }
    if (field.is_primary_key) {
        text += ' PK';
    }
    if (field.references) {
        const ref = field.references;
        text += ` FK ${ref.type} ${ref.table}.${ref.field}`;
    }
    return text;
}
function astToText(ast) {
    let text = '';
    text += guide_1.makeGuide('https://erd.surge.sh or https://quick-erd.surge.sh').replace(' or ', '\n# or ');
    for (const table of ast.table_list) {
        text += '\n\n\n' + tableToString(table).trim();
    }
    text += '\n\n';
    if (ast.zoom) {
        text += '\n' + meta_1.zoomToLine(ast.zoom);
    }
    if (ast.view) {
        text += '\n' + meta_1.viewToLine(ast.view);
    }
    for (const table of ast.table_list) {
        if (table.position) {
            text += '\n' + meta_1.tableNameToLine(table.name, table.position);
        }
    }
    return text.trim();
}
exports.astToText = astToText;
function printTables(tables) {
    tables = skipTimestamps(tables);
    const text = astToText({ table_list: tables });
    // eslint-disable-next-line no-console
    console.log(text);
}
exports.printTables = printTables;
const skip_tables = [
    'knex_migrations',
    'knex_migrations_lock',
    'sqlite_sequence',
];
const skip_fields = ['created_at', 'updated_at'];
function skipTimestamps(tables) {
    return tables
        .filter(table => !skip_tables.includes(table.name))
        .map(table => (Object.assign(Object.assign({}, table), { field_list: table.field_list.filter(field => !skip_fields.includes(field.name)) })));
}
