"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const enum_1 = require("./enum");
const meta_1 = require("./meta");
function parse(input) {
    const parser = new Parser();
    parser.parse(input);
    return parser;
}
exports.parse = parse;
class Parser {
    constructor() {
        this.table_list = [];
        this.line_list = [];
    }
    parse(input) {
        input.split('\n').forEach(line => {
            line = line
                .trim()
                .replace(/#.*/, '')
                .replace(/\/\/.*/, '')
                .trim();
            if (!line)
                return;
            this.line_list.push(line);
        });
        this.table_list = [];
        while (this.hasTable()) {
            this.table_list.push(this.parseTable());
        }
        this.parseMeta(input);
    }
    parseMeta(input) {
        var _a, _b;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-non-null-asserted-optional-chain
        const zoom = +((_a = input.match(meta_1.zoomValueRegex)) === null || _a === void 0 ? void 0 : _a[1]);
        if (zoom)
            this.zoom = zoom;
        const view = input.match(meta_1.viewPositionRegex);
        if (view)
            this.view = { x: +view[1], y: +view[2] };
        (_b = input.match(meta_1.tableNameRegex_g)) === null || _b === void 0 ? void 0 : _b.forEach(line => {
            const match = line.match(meta_1.tableNameRegex) || [];
            const name = match[1];
            const x = +match[2];
            const y = +match[3];
            const table = this.table_list.find(table => table.name == name);
            if (table)
                table.position = { x, y };
        });
    }
    peekLine() {
        if (this.line_list.length === 0) {
            throw new Error('no reminding line');
        }
        return this.line_list[0];
    }
    hasTable() {
        var _a;
        while (this.line_list[0] === '')
            this.line_list.shift();
        return this.line_list[0] && ((_a = this.line_list[1]) === null || _a === void 0 ? void 0 : _a.startsWith('-'));
    }
    parseTable() {
        const name = this.parseName();
        this.parseEmptyLine();
        this.skipLine('-');
        const field_list = parseAll(() => {
            // skip empty lines
            if (this.hasTable()) {
                throw new Error('end of table');
            }
            return this.parseField();
        });
        const has_primary_key = field_list.some(field => field.is_primary_key);
        if (!has_primary_key) {
            const field = field_list.find(field => field.name === 'id');
            if (field) {
                field.is_primary_key = true;
            }
        }
        return { name, field_list };
    }
    parseField() {
        const field_name = this.parseName();
        let type = defaultFieldType;
        let is_null = false;
        let is_unique = false;
        let is_primary_key = false;
        let is_unsigned = false;
        let references;
        for (;;) {
            const name = this.parseType();
            if (!name)
                break;
            switch (name.toUpperCase()) {
                case 'NULL':
                    is_null = true;
                    continue;
                case 'UNIQUE':
                    is_unique = true;
                    continue;
                case 'UNSIGNED':
                    is_unsigned = true;
                    continue;
                case 'PK':
                    is_primary_key = true;
                    continue;
                case 'FK':
                    references = this.parseForeignKeyReference(field_name);
                    continue;
                default:
                    type = name;
            }
        }
        this.skipLine();
        return {
            name: field_name,
            type,
            is_null,
            is_unique,
            is_primary_key,
            is_unsigned,
            references,
        };
    }
    skipLine(line = '') {
        var _a;
        if ((_a = this.line_list[0]) === null || _a === void 0 ? void 0 : _a.startsWith(line)) {
            this.line_list.shift();
        }
    }
    parseEmptyLine() {
        var _a;
        const line = (_a = this.line_list[0]) === null || _a === void 0 ? void 0 : _a.trim();
        if (line !== '') {
            throw new NonEmptyLineError(line);
        }
        this.line_list.shift();
    }
    parseName() {
        let line = this.peekLine();
        const match = line.match(/[a-zA-Z0-9_]+/);
        if (!match) {
            throw new ParseNameError(line);
        }
        const name = match[0];
        line = line.replace(name, '').trim();
        this.line_list[0] = line;
        return name;
    }
    parseType() {
        let line = this.peekLine();
        const match = line.match(/\w+\(.*?\)/) || line.match(/[a-zA-Z0-9_(),"']+/);
        if (!match) {
            return;
        }
        const name = match[0];
        line = line.replace(name, '').trim();
        this.line_list[0] = line;
        if (name.match(/^enum/i)) {
            return enum_1.formatEnum(name);
        }
        return name;
    }
    parseRelationType() {
        let line = this.peekLine();
        const match = line.match(/.* /);
        if (!match) {
            throw new ParseRelationTypeError(line);
        }
        const type = match[0].trim();
        line = line.replace(match[0], '').trim();
        this.line_list[0] = line;
        return type;
    }
    parseForeignKeyReference(ref_field_name) {
        if (ref_field_name.endsWith('_id') && this.peekLine() === '') {
            return {
                table: ref_field_name.replace(/_id$/, ''),
                field: 'id',
                type: '>-',
            };
        }
        const type = this.parseRelationType();
        const table = this.parseName();
        const line = this.peekLine();
        let field;
        if (line == '') {
            field = 'id';
        }
        else if (line.startsWith('.')) {
            this.line_list[0] = line.slice(1);
            field = this.parseName();
        }
        else {
            throw new ParseForeignKeyReferenceError(line);
        }
        return { type, table, field };
    }
}
class NonEmptyLineError extends Error {
}
class LineError extends Error {
    constructor(line, message) {
        super(message);
        this.line = line;
    }
}
class ParseNameError extends LineError {
}
class ParseRelationTypeError extends LineError {
}
class ParseForeignKeyReferenceError extends LineError {
    constructor(line) {
        super(line, `expect '.', got '${line[0]}'`);
        this.line = line;
    }
}
function parseAll(fn) {
    const result_list = [];
    for (;;) {
        try {
            result_list.push(fn());
        }
        catch (error) {
            return result_list;
        }
    }
}
const defaultFieldType = 'integer';
