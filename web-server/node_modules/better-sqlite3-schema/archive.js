"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importArchive = exports.exportArchive = exports.DefaultSkipTables = void 0;
const tslib_1 = require("tslib");
const readline_1 = tslib_1.__importDefault(require("readline"));
const migrate_1 = require("./migrate");
exports.DefaultSkipTables = [migrate_1.DefaultMigrationTable];
/**
 * @description Usage Example: ./scripts/export-db.ts | xz -T0 - > data/db-archive.txt.xz
 *  */
function exportArchive(db, options) {
    const onLine = (options === null || options === void 0 ? void 0 : options.onLine) || defaultOnLine;
    const skipTables = (options === null || options === void 0 ? void 0 : options.skipTables) || exports.DefaultSkipTables;
    let select_table = db.prepare(/* sql */ `
select name, sql
from sqlite_master
where type = 'table'
`);
    let table_rows = select_table.all();
    for (let table_row of table_rows) {
        let tableName = table_row.name;
        if (skipTables === null || skipTables === void 0 ? void 0 : skipTables.includes(tableName)) {
            continue;
        }
        let createTable = table_row.sql;
        let count = db.prepare(`select count(*) from ${tableName}`).pluck().get();
        let firstRow = db.prepare(`select * from ${tableName} limit 1`).get() || {};
        let keys = Object.keys(firstRow);
        let headers = {
            tableName,
            createTable,
            keys,
            count,
        };
        onLine(JSON.stringify(headers));
        let K = keys.length;
        let cols = new Array(K); // reuse the same array to reduce memory consumption
        for (let row of db.prepare(`select * from ${tableName}`).iterate()) {
            for (let i = 0; i < K; i++) {
                cols[i] = row[keys[i]];
            }
            onLine(JSON.stringify(cols));
        }
    }
}
exports.exportArchive = exportArchive;
function defaultOnLine(line) {
    console.log(line);
}
/**
 * @description Usage Example: unxz -k -f -T0 -c data/db-archive.txt.xz | ./scripts/import-db.ts
 *  */
function importArchive(db, options) {
    const rl = (options === null || options === void 0 ? void 0 : options.rl) ||
        readline_1.default.createInterface({
            input: process.stdin,
            output: process.stdout,
            terminal: false,
        });
    const onTable = options === null || options === void 0 ? void 0 : options.onTable;
    const skipTables = (options === null || options === void 0 ? void 0 : options.skipTables) || exports.DefaultSkipTables;
    function parseTableMeta(line) {
        const meta = JSON.parse(line);
        const tableName = meta.tableName;
        const keys = meta.keys;
        const count = meta.count;
        onTable === null || onTable === void 0 ? void 0 : onTable(meta);
        if (count === 0) {
            onLine = parseTableMeta;
            return;
        }
        let insert;
        if (skipTables.includes(tableName)) {
            insert = { run: () => null };
        }
        else {
            const fields = keys.join(',');
            const values = keys.map(key => '?').join(',');
            const sql = `insert into ${tableName} (${fields}) values (${values})`;
            insert = db.prepare(sql);
        }
        let i = 0;
        onLine = (line) => {
            const cols = JSON.parse(line);
            insert.run(...cols);
            i++;
            if (i === count) {
                onLine = parseTableMeta;
            }
        };
    }
    let onLine = parseTableMeta;
    rl.on('line', line => {
        onLine(line);
    });
}
exports.importArchive = importArchive;
(function (importArchive) {
    function reportOnTable(meta) {
        console.log('import table:', {
            tableName: meta.tableName,
            keys: meta.keys,
            count: meta.count.toLocaleString(),
        });
    }
    importArchive.reportOnTable = reportOnTable;
})(importArchive = exports.importArchive || (exports.importArchive = {}));
//# sourceMappingURL=archive.js.map