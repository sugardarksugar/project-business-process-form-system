"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeImports = exports.makeRefTableIndexSql = exports.makeRefTables = exports.makeTable = exports.makeTables = exports.makeRowName = exports.makeCacheName = exports.makeCountStatementName = exports.makeInsertStatementName = exports.makeSelectStatementName = exports.makeCreateTableSql = exports.toDataFieldNames = exports.toRowFieldNames = exports.toFieldNames = exports.makeRowType = exports.makeInsertSql = void 0;
const helpers_1 = require("./helpers");
const array_1 = require("./utils/array");
const compare_1 = require("./utils/compare");
const string_1 = require("./utils/string");
function makeInsertSql(table, fields) {
    table = (0, helpers_1.escapeField)(table);
    const cols = fields.map(col => '  ' + (0, helpers_1.escapeField)(col)).join(',\n');
    const values = fields.map(() => '?').join(',');
    return `insert into ${table} (
${cols}
) values (${values})`;
}
exports.makeInsertSql = makeInsertSql;
function makeRowType(fields) {
    const keys = fields.map(helpers_1.escapeField).join(' | ');
    return `Partial<Record<${keys}, SqliteDataType>>`;
}
exports.makeRowType = makeRowType;
function toFieldNames(schema) {
    return (0, array_1.uniqueArray)([
        schema.idField || '',
        ...Object.keys(schema.fields || {}),
        ...(schema.deduplicateFields || []),
    ].filter(s => s)).map(helpers_1.escapeField);
}
exports.toFieldNames = toFieldNames;
function toRowFieldNames(schema) {
    return (0, array_1.uniqueArray)([
        schema.idField || '',
        ...Object.keys(schema.fields || {}),
        ...(0, helpers_1.toRefIdFieldNames)(schema),
        ...(schema.deduplicateFields || []),
    ].filter(s => s));
}
exports.toRowFieldNames = toRowFieldNames;
function toDataFieldNames(schema) {
    return (0, array_1.uniqueArray)([
        schema.idField || '',
        ...Object.keys(schema.fields || {}),
        ...(0, helpers_1.toRefFieldNames)(schema),
        ...(schema.deduplicateFields || []),
    ].filter(s => s));
}
exports.toDataFieldNames = toDataFieldNames;
function makeCreateTableSql(schema) {
    const table = (0, helpers_1.escapeField)(schema.table);
    const cols = [];
    Object.entries(schema.fields || {}).forEach(([field, type]) => {
        cols.push((0, helpers_1.escapeField)(field) + ' ' + type);
    });
    (0, helpers_1.toRefIdFieldNames)(schema).forEach(field => cols.push((0, helpers_1.escapeField)(field) + ' integer'));
    if (schema.primaryKeys) {
        const fields = schema.primaryKeys.map(helpers_1.escapeField).join(', ');
        cols.push(`primary key(${fields})`);
    }
    const col = cols.map(col => '  ' + col).join(',\n');
    return `create table if not exists ${table} (
${col}
)`;
}
exports.makeCreateTableSql = makeCreateTableSql;
function makeSelectStatementName(field) {
    return `select_${field}_statement`;
}
exports.makeSelectStatementName = makeSelectStatementName;
function makeInsertStatementName(field) {
    return `insert_${field}_statement`;
}
exports.makeInsertStatementName = makeInsertStatementName;
function makeCountStatementName(field) {
    return `count_${field}_statement`;
}
exports.makeCountStatementName = makeCountStatementName;
function makeCacheName(field) {
    return `${field}_cache`;
}
exports.makeCacheName = makeCacheName;
function makeRowName(field) {
    return `${field}_row`;
}
exports.makeRowName = makeRowName;
function makeTables(schemas) {
    return schemas.map(makeTable).join('\n');
}
exports.makeTables = makeTables;
function makeTable(schema) {
    const tableName = (0, string_1.toCamelCase)(schema.table);
    const refSchemas = (0, helpers_1.toRefSchemas)(schema);
    const fields = toFieldNames(schema);
    const refIdFields = (0, helpers_1.toRefIdFieldNames)(schema);
    const rowFields = toRowFieldNames(schema);
    const dataFields = toDataFieldNames(schema);
    const insertSql = makeInsertSql(schema.table, rowFields);
    const rowType = makeRowType(rowFields);
    const dataType = makeRowType(dataFields);
    const createTableSql = schema.createTableSql || makeCreateTableSql(schema);
    const insertRowValues = [
        ...fields.map(field => `data[${field}]`),
        ...refIdFields,
    ];
    const getRefValues = refSchemas.map(makeInlineGetRefId).join('');
    const insertName = makeInsertStatementName(schema.table);
    const insertFnName = 'insert' + tableName;
    let code = `
export type ${tableName}Data = ${dataType}
export type ${tableName}Row = ${rowType}

${schema.autoCreateTable ? `db.exec(\`${createTableSql}\`)` : ''}
${schema.createIndexSql ? `db.exec(\`${schema.createIndexSql}\`)` : ''}
const ${insertName} = db.prepare(\`${insertSql}\`)

export function ${insertFnName}(data: ${tableName}Data): Int {
${getRefValues}
  return ${insertName}.run(
${insertRowValues.map(field => '    ' + field).join(',\n')}
  ).lastInsertRowid;
}
`;
    if (schema.deduplicateFields && schema.idField) {
        code += makeDeduplicatedTable(Object.assign(schema));
    }
    return code;
}
exports.makeTable = makeTable;
function makeInlineGetRefId(refField) {
    if (refField.cacheSize) {
        return makeInlineGetCachedRefId(refField);
    }
    const field = refField.field;
    const idField = refField.idField;
    const select = makeSelectStatementName(idField);
    const insert = makeInsertStatementName(field);
    return `
  let ${idField} = null
  const ${field} = data["${field}"]
  if (${field} !== undefined && ${field} !== null) {
    const row = ${select}.get(${field})
    ${idField} = row
      ? row["${idField}"]
      : ${insert}.run(${field}).lastInsertRowid
  }
`;
}
function makeInlineGetCachedRefId(refField) {
    const field = refField.field;
    const idField = refField.idField;
    const cache = makeCacheName(idField);
    const select = makeSelectStatementName(idField);
    const insert = makeInsertStatementName(field);
    return `
  const ${field} = data["${field}"]
  const ${idField} =
    ${field} === undefined || ${field} === null
      ? null
      : ${cache}.get(${field} as string, (fieldData: string) => {
          const row = ${select}.get(fieldData)
          return row
            ? row["${idField}"]
            : ${insert}.run(fieldData).lastInsertRowid
        })
`;
}
function makeRefTables(schemas) {
    const refSchemas = [];
    schemas.forEach(schema => refSchemas.push(...(0, helpers_1.toRefSchemas)(schema)));
    const createdTableSqls = new Set();
    return refSchemas
        .map((refSchema) => {
        const field = refSchema.field;
        const idField = refSchema.idField;
        const createTableSql = (0, helpers_1.makeCreateRefTableSql)(refSchema);
        if (createdTableSqls.has(createTableSql)) {
            return '';
        }
        createdTableSqls.add(createTableSql);
        const createIndexSql = makeRefTableIndexSql(field);
        const selectId = makeSelectStatementName(idField);
        const selectIdSql = `select "${idField}" from "${field}" where "${field}" = ?`;
        const insert = makeInsertStatementName(field);
        const insertSql = `insert into "${field}" ("${field}") values (?)`;
        let code = '';
        if (refSchema.autoCreateTable) {
            code += `
db.exec(\`${createTableSql}\`)`;
        }
        if (refSchema.autoCreateIndex) {
            code += `
db.exec(\`${createIndexSql}\`)`;
        }
        code += `
export const ${selectId}: Statement = db.prepare(\`${selectIdSql}\`)
export const ${insert}: Statement = db.prepare(\`${insertSql}\`)`;
        if (refSchema.cacheSize) {
            const cacheName = makeCacheName(idField);
            const size = refSchema.cacheSize;
            code += `
export const ${cacheName} = newCache({ resetSize: ${size} })`;
        }
        return code + '\n';
    })
        .join('');
}
exports.makeRefTables = makeRefTables;
function makeRefTableIndexSql(field) {
    return (0, helpers_1.makeUniqueIndexSql)(field, [field]);
}
exports.makeRefTableIndexSql = makeRefTableIndexSql;
// TODO make this standalone, without being proxied from makeTable
function makeDeduplicatedTable(schema) {
    const table = schema.table;
    const tableName = (0, string_1.toCamelCase)(table);
    const idField = schema.idField;
    const deduplicateFields = schema.deduplicateFields;
    const rowFields = toRowFieldNames(schema);
    const indexSql = schema.createIndexSql || (0, helpers_1.makeUniqueIndexSql)(table, deduplicateFields);
    const select = makeCountStatementName(idField);
    const selectSql = `select count(*) count from "${table}" where "${idField}" = ?`;
    const insert = 'deduplicated_' + makeInsertStatementName(table);
    const insertSql = makeInsertSql(schema.table, rowFields);
    const fields = toFieldNames(schema);
    const refIdFields = (0, helpers_1.toRefIdFieldNames)(schema);
    const insertRowValues = [
        ...fields.map(field => `data[${field}]`),
        ...refIdFields,
    ];
    const refSchemas = (0, helpers_1.toRefSchemas)(schema);
    const getRefValues = refSchemas
        .map(makeInlineGetRefId)
        .map(line => '  ' + line)
        .join('');
    const insertFnName = 'deduplicatedInsert' + tableName;
    // TODO support cache
    return `
${schema.autoCreateIndex ? `db.exec(\`${indexSql}\`)` : ''}
export const ${select}: Statement = db.prepare(\`${selectSql}\`)
export const ${insert}: Statement = db.prepare(\`${insertSql}\`)

export function ${insertFnName}(data: ${tableName}Data): Int {
  const id = data["${idField}"]
  const row = ${select}.get(id)
  if (!row.count) {
${getRefValues}
    ${insert}.run(
${insertRowValues.map(field => '      ' + field).join(',\n')}
    )
  }
  return id as any
}
`;
}
function makeImports(schemas, extraImports) {
    const imports = [
        `import { Statement } from 'better-sqlite3'`,
        `import { SqliteDataType, Int } from 'better-sqlite3-schema'`,
        ...(extraImports || []),
    ];
    const hasCache = schemas.some(schema => {
        var _a;
        return (_a = schema.refFields) === null || _a === void 0 ? void 0 : _a.some(refField => {
            var _a;
            if (typeof refField === 'string') {
                return (_a = schema.cacheFields) === null || _a === void 0 ? void 0 : _a.includes(refField);
            }
            return refField.cacheSize;
        });
    });
    if (hasCache) {
        imports.push(`import { newCache } from 'better-sqlite3-schema'`);
    }
    return sortImports(imports).join('\n');
}
exports.makeImports = makeImports;
function sortImports(imports) {
    return imports
        .map(code => {
        const module = code.split(' ').pop();
        return { code, module };
    })
        .sort((a, b) => (0, compare_1.compare)(a.module, b.module))
        .map(a => a.code);
}
//# sourceMappingURL=codegen.js.map