"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePreparedRefFns = exports.makeCachedPreparedRefFns = exports.makeCachedPreparedGetRefIdFn = exports.getRefValueFromCache = exports.loadAllRefCache = exports.toSafeMode = exports.toExportMode = exports.makeUniqueIndexSql = exports.makeCreateRefTableSql = exports.escapeField = exports.cacheAllRefFields = exports.iterateRows = exports.makeSelectJoin = exports.makeSelectRefFieldArray = exports.countRows = exports.makeGetRefValueFnFromSchema = exports.makeSelectRefFieldSql = exports.makeSelectRowFnFromSchema = exports.forEach = exports.insertArrayField = exports.makeSchemaScanner = exports.isInt = exports.toSqliteDataType = exports.makeAutoAddFieldMapRowFn = exports.addField = exports.makeTableInfo = exports.setUnsafeMode = exports.vacuum = exports.removeAllTables = exports.removeAllIndices = exports.removeAllTableIndicesAndPrimaryKeys = exports.removeTableIndicesAndPrimaryKeys = exports.removeTableIndices = exports.getAllIndices = exports.getAllTables = exports.getTableIndices = exports.getTableFields = exports.makeInsertRefSqls = exports.toRefSchema = exports.toRefSchemas = exports.makeDeduplicatedInsertRowFnFromSchema = exports.defaultTableFields = exports.toRefFieldNames = exports.toRefIdFieldNames = exports.defaultIdFieldSuffix = exports.makeInsertRowFnFromSchema = exports.createDB = exports.delDBFile = void 0;
const cache_1 = require("./utils/cache");
const function_1 = require("./utils/function");
const db_1 = require("./db");
function delDBFile(file) {
    const fs = require('fs');
    const files = [file, file + '-shm', file + '-wal'];
    files.forEach(file => {
        if (fs.existsSync(file)) {
            fs.unlinkSync(file);
        }
    });
}
exports.delDBFile = delDBFile;
function createDB(options) {
    const file = options.file;
    if (options.mode === 'overwrite') {
        delDBFile(file);
    }
    delete options.mode;
    return (0, db_1.newDB)(Object.assign({ path: file, migrate: false }, options));
}
exports.createDB = createDB;
function makeInsertRowFnFromSchema(db, schema) {
    autoCreateTable(db, schema);
    autoCreateIndexFromSchema(db, schema);
    let insertRowFn = makeInsertRowFn(db, schema.table);
    if (schema.autoAddField) {
        const table = makeTableInfo(db, schema.table);
        insertRowFn = (0, function_1.chain)(makeAutoAddFieldMapRowFn(db, table), insertRowFn);
    }
    if (schema.refFields) {
        const refFields = toRefSchemas(schema).map(refSchema => makeInsertRefField(db, refSchema));
        insertRowFn = (0, function_1.chain)(makeInsertRefFieldsMapRowFn(refFields), insertRowFn);
    }
    if (schema.skipFields) {
        insertRowFn = (0, function_1.chain)(makeSkipFieldsMapRowFn(schema.skipFields), insertRowFn);
    }
    const whitelistFields = getWhitelistFields(schema);
    if (whitelistFields) {
        insertRowFn = (0, function_1.chain)(makeWhitelistFieldsMapRowFn(whitelistFields), insertRowFn);
    }
    if (!(schema === null || schema === void 0 ? void 0 : schema.inplaceUpdate)) {
        insertRowFn = (0, function_1.chain)(cloneRowFn, insertRowFn);
    }
    return insertRowFn;
}
exports.makeInsertRowFnFromSchema = makeInsertRowFnFromSchema;
function getWhitelistFields(schema) {
    if (!schema.whitelistFields) {
        return;
    }
    if (Array.isArray(schema.whitelistFields)) {
        return schema.whitelistFields;
    }
    if (!schema.fields) {
        return;
    }
    return [...Object.keys(schema.fields), ...toRefIdFieldNames(schema)];
}
exports.defaultIdFieldSuffix = '_id';
function toRefIdFieldNames(schema) {
    return (schema.refFields || []).map(refField => typeof refField === 'string'
        ? refField + (schema.idFieldSuffix || exports.defaultIdFieldSuffix)
        : refField.idField);
}
exports.toRefIdFieldNames = toRefIdFieldNames;
function toRefFieldNames(schema) {
    return (schema.refFields || []).map(refField => typeof refField === 'string' ? refField : refField.field);
}
exports.toRefFieldNames = toRefFieldNames;
exports.defaultTableFields = {
    id: `integer primary key`,
};
function autoCreateTable(db, schema) {
    if (schema.createTableSql) {
        return db.exec(schema.createTableSql);
    }
    if (!schema.autoCreateTable) {
        return;
    }
    const fields = schema.fields || exports.defaultTableFields;
    toRefIdFieldNames(schema).forEach(field => (fields[field] = 'integer'));
    const bodySqls = Object.entries(fields).map(nameAndType => nameAndType.join(' '));
    if (schema.primaryKeys) {
        const fields = schema.primaryKeys.map(escapeField).join(',');
        bodySqls.push(`primary key (${fields})`);
    }
    const bodySql = bodySqls.join(',');
    const sql = `create table if not exists "${schema.table}" (${bodySql})`;
    db.exec(sql);
}
function autoCreateIndexFromSchema(db, schema) {
    if (schema.createIndexSql) {
        return db.exec(schema.createIndexSql);
    }
}
function makeInsertRowFn(db, table) {
    return row => {
        return db.insert(table, row);
    };
}
function makeDeduplicatedInsertRowFn(options, insertRowFn) {
    const deduplicateFields = options.deduplicateFields;
    const idField = options.idField;
    const select = options.select;
    return row => {
        const selectArgs = deduplicateFields.map(field => row[field]);
        const matchedRow = select.get(...selectArgs);
        if (matchedRow) {
            return matchedRow[idField];
        }
        return insertRowFn(row);
    };
}
function makeDeduplicatedInsertRowFnFromSchema(db, schema, insertRowFn) {
    autoCreateIndexFromDeduplicatedSchema(db, schema);
    const idField = schema.idField;
    const deduplicateFields = schema.deduplicateFields;
    const whereSql = deduplicateFields.map(field => `"${field}" = ?`).join(' or ');
    const select = db.prepare(`select "${idField}" from "${schema.table}" where ${whereSql}`);
    const deduplicatedInsertRowFn = makeDeduplicatedInsertRowFn({
        select,
        idField,
        deduplicateFields,
    }, insertRowFn);
    const cache = toCache(schema);
    if (!cache) {
        return deduplicatedInsertRowFn;
    }
    return row => {
        const key = JSON.stringify(deduplicateFields.map(field => row[field]));
        return cache.get(key, () => deduplicatedInsertRowFn(row));
    };
}
exports.makeDeduplicatedInsertRowFnFromSchema = makeDeduplicatedInsertRowFnFromSchema;
function autoCreateIndexFromDeduplicatedSchema(db, schema) {
    if (!schema.autoCreateIndex) {
        return;
    }
    createUniqueIndexIfNotExist(db, schema.table, schema.deduplicateFields);
}
function cloneRowFn(row) {
    return Object.assign({}, row);
}
function makeWhitelistFieldsMapRowFn(whitelistFields) {
    return (row) => {
        const res = {};
        whitelistFields.forEach(field => (res[field] = row[field]));
        return res;
    };
}
function makeSkipFieldsMapRowFn(skipFields) {
    return (row) => {
        skipFields.forEach(field => delete row[field]);
        return row;
    };
}
function makeInsertRefFieldsMapRowFn(refFields) {
    return (row) => {
        refFields.forEach(refField => {
            const field = refField.field;
            if (!(field in row)) {
                return;
            }
            const data = row[field];
            const id = refField.getRefIdFn(refField, data);
            delete row[field];
            row[refField.idField] = id;
        });
        return row;
    };
}
function toRefSchemas(schema) {
    return (schema.refFields || []).map(refField => toRefSchema(refField, schema));
}
exports.toRefSchemas = toRefSchemas;
function toRefSchema(refField, schema) {
    var _a;
    if (typeof refField !== 'string') {
        return refField;
    }
    const field = refField;
    const idField = field + (schema.idFieldSuffix || exports.defaultIdFieldSuffix);
    const refFieldSchema = {
        field,
        idField,
        autoCreateTable: schema.autoCreateTable,
        autoCreateIndex: schema.autoCreateIndex,
    };
    if ((_a = schema.cacheFields) === null || _a === void 0 ? void 0 : _a.includes(field)) {
        refFieldSchema.cache = schema.cache;
        refFieldSchema.cacheSize = schema.cacheSize;
    }
    return refFieldSchema;
}
exports.toRefSchema = toRefSchema;
function makeInsertRefField(db, schema) {
    const field = schema.field;
    const sqls = makeInsertRefSqls(db, schema);
    return {
        field,
        idField: schema.idField,
        select: sqls.select,
        insert: sqls.insert,
        getRefIdFn: makeGetRefIdFn(schema),
    };
}
function makeGetRefIdFn(refField) {
    const cache = toCache(refField);
    if (cache) {
        return makeCachedGetRefIdFn(cache);
    }
    return getRefId;
}
function createRefTableIfNotExist(db, schema) {
    db.exec(makeCreateRefTableSql(schema));
}
function createUniqueIndexIfNotExist(db, table, fields) {
    db.exec(makeUniqueIndexSql(table, fields));
}
function makeInsertRefSqls(db, schema) {
    const field = schema.field;
    const table = field;
    const idField = schema.idField;
    if (schema.autoCreateTable) {
        createRefTableIfNotExist(db, schema);
    }
    if (schema.autoCreateIndex) {
        createUniqueIndexIfNotExist(db, table, [field]);
    }
    const select = db.prepare(`select "${idField}" from "${field}" where "${field}" = ? limit 1`);
    const insert = db.prepare(`insert into "${field}" ("${field}") values (?)`);
    return { select, insert, idField };
}
exports.makeInsertRefSqls = makeInsertRefSqls;
function getRefId(refSqls, fieldData) {
    if (fieldData === undefined || fieldData === null) {
        return null;
    }
    const row = refSqls.select.get(fieldData);
    if (row) {
        return row[refSqls.idField];
    }
    return refSqls.insert.run(fieldData).lastInsertRowid;
}
function makeCachedGetRefIdFn(cache) {
    return (refSqls, fieldData) => fieldData === undefined || fieldData === null
        ? null
        : cache.get(fieldData, () => getRefId(refSqls, fieldData));
}
function getTableFields(db, table) {
    return db.prepare(`PRAGMA table_info("${table}")`).all();
}
exports.getTableFields = getTableFields;
function getTableIndices(db, table) {
    return db
        .prepare(`select * from sqlite_master where type = 'index' and tbl_name = ?`)
        .all(table);
}
exports.getTableIndices = getTableIndices;
function getAllTables(db) {
    return db.prepare(`select * from sqlite_master where type = 'table'`).all();
}
exports.getAllTables = getAllTables;
function getAllIndices(db) {
    return db.prepare(`select * from sqlite_master where type = 'index'`).all();
}
exports.getAllIndices = getAllIndices;
function removeTableIndices(db, table) {
    getTableIndices(db, table).forEach(row => {
        db.exec(`drop index if exists "${row.name}"`);
    });
}
exports.removeTableIndices = removeTableIndices;
/** remove all indices, including those for primary key */
function removeTableIndicesAndPrimaryKeys(db, table) {
    db.transaction(recreateTable)(db, table);
}
exports.removeTableIndicesAndPrimaryKeys = removeTableIndicesAndPrimaryKeys;
/** remove all indices, including those for primary key */
function removeAllTableIndicesAndPrimaryKeys(db) {
    db.transaction(recreateAllTable)(db);
}
exports.removeAllTableIndicesAndPrimaryKeys = removeAllTableIndicesAndPrimaryKeys;
function recreateAllTable(db) {
    getAllTables(db).forEach(row => recreateTable(db, row.name));
}
function recreateTable(db, table) {
    db.exec(`
create table "tmp_${table}" as select * from "${table}";
drop table "${table}";
alter table "tmp_${table}" rename to "${table}";
`);
}
function removeAllIndices(db) {
    getAllIndices(db).forEach(row => {
        if (!row.sql) {
            return; // skip index of primary key
        }
        db.exec(`drop index if exists "${row.name}"`);
    });
}
exports.removeAllIndices = removeAllIndices;
function removeAllTables(db) {
    getAllTables(db).forEach(row => {
        db.exec(`drop table if exists "${row.name}"`);
    });
}
exports.removeAllTables = removeAllTables;
function vacuum(db) {
    db.exec(`VACUUM`);
}
exports.vacuum = vacuum;
function setUnsafeMode(db, enable) {
    const rawDB = db.connection();
    rawDB.unsafeMode(enable);
}
exports.setUnsafeMode = setUnsafeMode;
function makeTableInfo(db, table) {
    const fields = {};
    getTableFields(db, table).forEach(column => (fields[column.name] = column.type));
    return {
        table,
        fields,
    };
}
exports.makeTableInfo = makeTableInfo;
function addField(db, table, field, type) {
    const sql = `alter table "${table.table}" add ${field} ${type};`;
    db.exec(sql);
    table.fields[field] = type;
}
exports.addField = addField;
function makeAutoAddFieldMapRowFn(db, table) {
    return (row) => {
        Object.keys(row).forEach(field => {
            if (field in table.fields) {
                return;
            }
            const type = toSqliteDataType(row[field]);
            addField(db, table, field, type);
        });
        return row;
    };
}
exports.makeAutoAddFieldMapRowFn = makeAutoAddFieldMapRowFn;
function toSqliteDataType(fieldData) {
    switch (typeof fieldData) {
        case 'string':
            return 'text';
        case 'boolean':
            return 'integer';
        case 'object':
            return 'json';
        case 'number': {
            return isInt(fieldData) ? 'integer' : 'real';
        }
    }
    return 'blob';
}
exports.toSqliteDataType = toSqliteDataType;
function isInt(number) {
    const int = parseInt(number, 10);
    return int === +number;
}
exports.isInt = isInt;
function makeSchemaScanner() {
    const fields = {};
    const addRowFn = (row) => {
        Object.keys(row).forEach(field => {
            if (field in fields) {
                return;
            }
            const type = toSqliteDataType(row[field]);
            fields[field] = type;
        });
    };
    return { fields, addRowFn };
}
exports.makeSchemaScanner = makeSchemaScanner;
function toCache(options) {
    if (options.cache) {
        return options.cache;
    }
    if (options.cacheSize) {
        return (0, cache_1.newCache)({ resetSize: options.cacheSize });
    }
}
/**
 * @remark the rows will be updated in-place
 * */
function insertArrayField(rows, idFields, insertRowFn) {
    rows === null || rows === void 0 ? void 0 : rows.forEach(row => {
        Object.assign(row, idFields);
        insertRowFn(row);
    });
}
exports.insertArrayField = insertArrayField;
function forEach(rows, fn) {
    rows === null || rows === void 0 ? void 0 : rows.forEach(fn);
}
exports.forEach = forEach;
function makeSelectRowFnFromSchema(db, schema) {
    const select = db.prepare(`select * from "${schema.table}" limit 1 offset ?`);
    let selectRowFn = offset => select.get(offset);
    if (schema.refFields) {
        const refFields = toRefSchemas(schema).map(refSchema => makeSelectRefField(db, refSchema));
        selectRowFn = (0, function_1.chain)(selectRowFn, makeSelectRefFieldsMapRowFn(refFields));
    }
    return selectRowFn;
}
exports.makeSelectRowFnFromSchema = makeSelectRowFnFromSchema;
function makeSelectRefField(db, schema) {
    const field = schema.field;
    const idField = schema.idField;
    return {
        field,
        idField,
        select: makeSelectRefFieldSql(db, field, idField),
        getRefValueFn: makeGetRefValueFn(schema),
    };
}
function makeSelectRefFieldSql(db, field, idField = field + exports.defaultIdFieldSuffix) {
    return db.prepare(`select "${field}" from "${field}" where "${idField}" = ?`);
}
exports.makeSelectRefFieldSql = makeSelectRefFieldSql;
function makeGetRefValueFnFromSchema(db, schema) {
    const field = schema.field;
    const idField = schema.idField || field + exports.defaultIdFieldSuffix;
    const select = makeSelectRefFieldSql(db, field, idField);
    const getRefValueFn = makeGetRefValueFn(schema);
    return (fieldId) => getRefValueFn(select, field, fieldId);
}
exports.makeGetRefValueFnFromSchema = makeGetRefValueFnFromSchema;
function makeGetRefValueFn(refField) {
    const cache = toCache(refField);
    if (cache) {
        return makeCachedGetRefValueFn(cache);
    }
    return getRefValue;
}
function getRefValue(select, field, fieldId) {
    return select.get(fieldId)[field];
}
function makeCachedGetRefValueFn(cache) {
    return (select, field, fieldId) => cache.get(fieldId, () => getRefValue(select, field, fieldId));
}
function makeSelectRefFieldsMapRowFn(refFields) {
    return (row) => {
        refFields.forEach(refField => {
            const idField = refField.idField;
            if (!(idField in row)) {
                return;
            }
            const field = refField.field;
            const id = row[idField];
            const fieldValue = refField.getRefValueFn(refField.select, field, id);
            delete row[idField];
            row[field] = fieldValue;
        });
        return row;
    };
}
function countRows(db, table) {
    return db.queryFirstCell(`select count(*) from "${table}"`);
}
exports.countRows = countRows;
function makeSelectRefFieldArray(db, schema) {
    const res = makeSelectJoin(db, Object.assign({ fromTable: schema.table, joinTable: schema.field, joinField: toJoinField(schema) }, schema));
    return res.all;
}
exports.makeSelectRefFieldArray = makeSelectRefFieldArray;
function toJoinField(schema) {
    if ('joinField' in schema) {
        return schema.joinField;
    }
    return schema.field + (schema.idFieldSuffix || exports.defaultIdFieldSuffix);
}
function makeSelectJoin(db, schema) {
    const field = schema.field;
    const joinTable = schema.joinTable;
    const fromTable = schema.fromTable;
    const joinField = schema.joinField;
    const idField = schema.idField;
    const sql = db.prepare(`select "${field}" from "${fromTable}" inner join "${joinTable}" on "${fromTable}"."${joinField}" = "${joinTable}"."${joinField}" where "${idField}" = ?`);
    let all = makeAllSelectJoin(sql, field);
    let get = makeGetSelectJoin(sql, field);
    const cache = toCache(schema);
    if (cache) {
        all = cache.wrapFn(all);
        get = cache.wrapFn(get);
    }
    return {
        sql,
        all,
        get,
    };
}
exports.makeSelectJoin = makeSelectJoin;
function makeGetSelectJoin(sql, field) {
    return (fieldId) => { var _a; return (_a = sql.get(fieldId)) === null || _a === void 0 ? void 0 : _a[field]; };
}
function makeAllSelectJoin(sql, field) {
    return (fieldId) => sql.all(fieldId).map(row => row[field]);
}
function* iterateRows(select, count) {
    for (let i = 0; i < count; i++) {
        yield select(i);
    }
}
exports.iterateRows = iterateRows;
function cacheAllRefFields(schema) {
    const cacheFields = new Set(schema.cacheFields);
    toRefFieldNames(schema).forEach(field => cacheFields.add(field));
    schema.cacheFields = Array.from(cacheFields);
}
exports.cacheAllRefFields = cacheAllRefFields;
function escapeField(field) {
    return JSON.stringify(field);
}
exports.escapeField = escapeField;
function makeCreateRefTableSql(schema) {
    const field = schema.field;
    const idField = schema.idField;
    const type = schema.type ? ' ' + schema.type : '';
    return `create table if not exists "${field}" (
  "${idField}" integer primary key,
  "${field}"${type}
)`;
}
exports.makeCreateRefTableSql = makeCreateRefTableSql;
function makeUniqueIndexSql(table, fields) {
    const fieldsSql = fields.map(escapeField).join(',');
    return `create unique index if not exists "${table}_unique_idx" on "${table}" (${fieldsSql})`;
}
exports.makeUniqueIndexSql = makeUniqueIndexSql;
function toExportMode(db, cache_size) {
    db.exec(`PRAGMA synchronous = OFF`);
    db.exec(`PRAGMA journal_mode = MEMORY`);
    setCacheSize(db, cache_size);
}
exports.toExportMode = toExportMode;
function toSafeMode(db, cache_size) {
    setCacheSize(db, cache_size);
    db.exec(`PRAGMA journal_mode = WAL`);
    db.exec(`PRAGMA synchronous = NORMAL`);
}
exports.toSafeMode = toSafeMode;
function setCacheSize(db, cache_size) {
    if (typeof cache_size === 'number') {
        db.exec(`PRAGMA cache_size = ${cache_size}`);
    }
}
function loadAllRefCache(db, field, idField = field + exports.defaultIdFieldSuffix) {
    const cache = {};
    for (const row of db
        .prepare(`select ${idField}, ${field} from ${field}`)
        .iterate()) {
        const id = row[idField];
        cache[id] = row[field];
    }
    return cache;
}
exports.loadAllRefCache = loadAllRefCache;
function getRefValueFromCache(cache, id, name = 'ref value') {
    if (id in cache) {
        return cache[id];
    }
    console.error(`unknown ${name} id:`, { id, cache });
    throw new Error(`unknown ${name} id`);
}
exports.getRefValueFromCache = getRefValueFromCache;
/**
 * select from existing record or insert and return new id
 * @deprecated use makeCachedPreparedRefFns() instead
 * */
function makeCachedPreparedGetRefIdFn(db, field, idFields = field + exports.defaultIdFieldSuffix) {
    return makeCachedPreparedRefFns(db, field, idFields).getRefId;
}
exports.makeCachedPreparedGetRefIdFn = makeCachedPreparedGetRefIdFn;
function makeCachedPreparedRefFns(db, field, idFields = field + exports.defaultIdFieldSuffix) {
    const select_id_statement = db.prepare(`
  select "${idFields}" from "${field}"
  where "${field}" = ?
  `);
    const select_val_statement = db.prepare(`
  select "${field}" from "${field}"
  where "${idFields}" = ?`);
    const insert_statement = db.prepare(`
  insert into "${field}" ("${field}") values (?)
  `);
    const select_all_statement = db.prepare(`
  select "${idFields}","${field}" from "${field}"
  `);
    const id_cache = {};
    const val_cache = {};
    /** select from existing record or insert and return new id */
    function getRefId(value) {
        if (value in val_cache) {
            return val_cache[value];
        }
        const row = select_id_statement.get(value);
        let id;
        if (row) {
            id = row[idFields];
        }
        else {
            id = insert_statement.run(value).lastInsertRowid;
        }
        val_cache[value] = id;
        return id;
    }
    function getRefValue(id) {
        id = id;
        if (id in id_cache) {
            return id_cache[id];
        }
        const row = select_val_statement.get(id);
        if (!row) {
            console.error(`unknown "${field}" id:`, id);
            throw new Error(`unknown "${field}" id`);
        }
        const value = row[field];
        id_cache[id] = value;
        return value;
    }
    function populateCache() {
        for (const row of select_all_statement.all()) {
            const id = row[idFields];
            const val = row[field];
            id_cache[id] = val;
            val_cache[val] = id;
        }
    }
    return {
        getRefValue,
        getRefId,
        populateCache,
        val_cache,
        id_cache,
    };
}
exports.makeCachedPreparedRefFns = makeCachedPreparedRefFns;
function makePreparedRefFns(db, field, idFields = field + exports.defaultIdFieldSuffix) {
    const select_id_statement = db.prepare(`
  select "${idFields}" from "${field}"
  where "${field}" = ?
  `);
    const select_val_statement = db.prepare(`
  select "${field}" from "${field}"
  where "${idFields}" = ?`);
    const insert_statement = db.prepare(`
  insert into "${field}" ("${field}") values (?)
  `);
    /** select from existing record or insert and return new id */
    function getRefId(value) {
        const row = select_id_statement.get(value);
        let id;
        if (row) {
            id = row[idFields];
        }
        else {
            id = insert_statement.run(value).lastInsertRowid;
        }
        return id;
    }
    function getRefValue(id) {
        id = id;
        const row = select_val_statement.get(id);
        if (!row) {
            console.error(`unknown "${field}" id:`, id);
            throw new Error(`unknown "${field}" id`);
        }
        return row[field];
    }
    return {
        getRefValue,
        getRefId,
    };
}
exports.makePreparedRefFns = makePreparedRefFns;
//# sourceMappingURL=helpers.js.map