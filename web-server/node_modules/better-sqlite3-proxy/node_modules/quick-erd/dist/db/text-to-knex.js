"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.textToKnex = exports.toKnexCreateTableCode = exports.toKnexCreateColumnCode = exports.toKnexCreateColumnTypeCode = void 0;
const ast_1 = require("../core/ast");
const sort_tables_1 = require("./sort-tables");
const type_alias = {
    blob: 'binary',
    int: 'integer',
};
const specific_types = ['real'];
function toKnexCreateColumnTypeCode(field) {
    let code = '';
    let type = field.type;
    if (type.match(/^enum/i)) {
        const values = type
            .replace(/^enum/i, '')
            .replace(/^\(/, '[')
            .replace(/\)$/, ']')
            .replace(/','/g, "', '");
        code += `.enum('${field.name}', ${values})`;
    }
    else {
        type = type.replace(/^varchar/i, 'string');
        let length = '';
        if (!length) {
            const match = type.match(/^string\((\d+)\)/i);
            if (match) {
                length = match[1];
                type = 'string';
            }
        }
        if (!length) {
            const match = type.match(/^int.*\((\d+)\)/i);
            if (match) {
                length = match[1];
                type = 'integer';
            }
        }
        type = type_alias[type] || type;
        if (specific_types.includes(type) || type.match(/^char\(\d+\)$/i)) {
            code += `.specificType('${field.name}', '${type}')`;
        }
        else if (length) {
            code += `.${type}('${field.name}', ${length})`;
        }
        else {
            code += `.${type}('${field.name}')`;
        }
        if (field.is_unsigned || field.references) {
            code += `.unsigned()`;
        }
    }
    return code;
}
exports.toKnexCreateColumnTypeCode = toKnexCreateColumnTypeCode;
function toKnexCreateColumnCode(field) {
    let code = `
      table`;
    if (field.is_primary_key) {
        code += `.increments('${field.name}')`;
        return code;
    }
    code += toKnexCreateColumnTypeCode(field);
    if (field.is_null) {
        code += `.nullable()`;
    }
    else {
        code += `.notNullable()`;
    }
    if (field.is_unique) {
        code += `.unique()`;
    }
    const ref = field.references;
    if (ref) {
        code += `.references('${ref.table}.${ref.field}')`;
    }
    return code;
}
exports.toKnexCreateColumnCode = toKnexCreateColumnCode;
function toKnexCreateTableCode(table) {
    let code = '';
    const fields = {};
    table.field_list.forEach(field => (fields[field.name] = field));
    if (fields.created_at && fields.updated_at) {
        delete fields.created_at;
        delete fields.updated_at;
    }
    code += `
  if (!(await knex.schema.hasTable('${table.name}'))) {
    await knex.schema.createTable('${table.name}', table => {`;
    Object.values(fields).forEach(field => {
        code += toKnexCreateColumnCode(field);
    });
    if (!fields.created_at && !fields.updated_at && !fields.timestamp) {
        code += `
      table.timestamps(false, true)`;
    }
    code += `
    })
  }`;
    return code;
}
exports.toKnexCreateTableCode = toKnexCreateTableCode;
function textToKnex(text) {
    const result = (0, ast_1.parse)(text);
    let code = `
import { Knex } from 'knex'

export async function up(knex: Knex): Promise<void> {`;
    const table_list = (0, sort_tables_1.sortTables)(result.table_list);
    table_list.forEach((table, i) => {
        if (i > 0)
            code += `\n`;
        code += toKnexCreateTableCode(table);
    });
    code += `
}

export async function down(knex: Knex): Promise<void> {`;
    table_list.reverse().forEach(table => {
        code += `
  await knex.schema.dropTableIfExists('${table.name}')`;
    });
    code += `
}
`;
    return code.trim();
}
exports.textToKnex = textToKnex;
