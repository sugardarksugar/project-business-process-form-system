"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scanPGTableSchema = void 0;
function toDataType(column_row) {
    if (column_row.data_type.includes('character varying')) {
        if (column_row.character_maximum_length) {
            return `varchar(${column_row.character_maximum_length})`;
        }
        return 'string';
    }
    if (column_row.data_type.includes('character')) {
        if (column_row.character_maximum_length) {
            return `char(${column_row.character_maximum_length})`;
        }
        return 'string';
    }
    if (column_row.data_type.match(/double precision/i)) {
        return 'double';
    }
    if (column_row.data_type.includes('timestamp')) {
        return 'timestamp';
    }
    return column_row.data_type;
}
function parseEnum(column_name, 
// e.g. ((status = ANY (ARRAY['active'::text, 'recall'::text])))
check_clause) {
    const matches = check_clause === null || check_clause === void 0 ? void 0 : check_clause.replace(column_name, 'column_name').match(/\(\(column_name = ANY \(ARRAY\[(.*)\]\)\)\)/);
    if (!matches)
        return null;
    const values = matches[1].split(',').map(value => {
        var _a;
        value = value.trim();
        value = ((_a = value.match(/('.*')::text/)) === null || _a === void 0 ? void 0 : _a[1]) || value;
        return value;
    });
    return `enum(${values})`;
}
function scanPGTableSchema(knex) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const table_list = [];
        const table_rows = yield knex
            .select('tablename')
            .from('pg_tables')
            .where({ schemaname: 'public' });
        for (const table_row of table_rows) {
            const table = {
                name: table_row.tablename,
                field_list: [],
            };
            if (table.name.startsWith('knex_migrations')) {
                continue;
            }
            table_list.push(table);
            const result = yield knex.raw(
            /* sql */ `
select
  column_name
, data_type
, character_maximum_length
, is_nullable
from information_schema.columns
where table_name = ?
`, [table.name]);
            const column_rows = result.rows;
            for (const column_row of column_rows) {
                /* check foreign key */
                let result = yield knex.raw(
                /* sql */
                `
SELECT
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM
    information_schema.table_constraints AS tc
    JOIN information_schema.key_column_usage AS kcu
      ON tc.constraint_name = kcu.constraint_name
      AND tc.table_schema = kcu.table_schema
    JOIN information_schema.constraint_column_usage AS ccu
      ON ccu.constraint_name = tc.constraint_name
      AND ccu.table_schema = tc.table_schema
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_name = ?
  AND kcu.column_name = ?
;
`, [table.name, column_row.column_name]);
                const fk_row = result.rows[0];
                /* check unique */
                result = yield knex.raw(
                /* sql */ `
SELECT
    ccu.column_name AS unique_column_name
FROM
    information_schema.table_constraints AS tc
    JOIN information_schema.key_column_usage AS kcu
      ON tc.constraint_name = kcu.constraint_name
      AND tc.table_schema = kcu.table_schema
    JOIN information_schema.constraint_column_usage AS ccu
      ON ccu.constraint_name = tc.constraint_name
      AND ccu.table_schema = tc.table_schema
WHERE tc.constraint_type = 'UNIQUE'
  AND tc.table_name = ?
  AND kcu.column_name = ?
;
`, [table.name, column_row.column_name]);
                const unique_row = result.rows[0];
                let type = toDataType(column_row);
                /* check enum */
                if (type === 'text') {
                    result = yield knex.raw(
                    /* sql */ `
SELECT check_clause
FROM information_schema.check_constraints
WHERE constraint_name = ?
;
`, `${table.name}_${column_row.column_name}_check`);
                    const check_clause = (_a = result.rows[0]) === null || _a === void 0 ? void 0 : _a.check_clause;
                    if (check_clause) {
                        type = parseEnum(column_row.column_name, check_clause) || type;
                    }
                }
                table.field_list.push({
                    name: column_row.column_name,
                    type,
                    is_primary_key: column_row.column_name === 'id' &&
                        (type === 'integer' || type === 'int'),
                    is_null: column_row.is_nullable === 'YES',
                    is_unsigned: false,
                    is_unique: !!unique_row,
                    references: fk_row
                        ? {
                            type: '>-',
                            table: fk_row.foreign_table_name,
                            field: fk_row.foreign_column_name,
                        }
                        : undefined,
                });
            }
        }
        return table_list;
    });
}
exports.scanPGTableSchema = scanPGTableSchema;
